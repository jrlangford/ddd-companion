# DDD Standards Validation

Validate an existing Go hexagonal architecture project against the DDD standards defined by ddd-implement.

## Purpose

This document defines the validation workflow for auditing a project that follows (or intends to follow) the patterns in ddd-implement. It references the existing pattern files as the authoritative rules — it does not restate them.

## When to Use

- After manual development has been done on a walking skeleton generated by ddd-implement
- When onboarding onto an existing project that claims to follow these DDD standards
- As a periodic health check during active development
- Before code review, to catch structural drift early

## Prerequisites

- A Go project using hexagonal architecture with bounded contexts
- The project root must contain `internal/` with context directories

Optional but useful:
- A `ddd-workspace/ddd-implement.manifest.json` (provides context names, entity lists, and expected file paths to validate against)
- BCR workspace FQBC documents (enables validation of domain completeness)

---

## Validation Report Format

Validation produces a Markdown report written to the project root as `ddd-validation-report.md`.

### Severity Levels

| Severity | Meaning | Examples |
|----------|---------|---------|
| **error** | Violates a hard architectural rule. The project does not conform to DDD standards. | Forbidden import, missing interface compliance assertion, cross-context domain import |
| **warning** | Deviates from a naming or structural convention. Functional but inconsistent. | Wrong package name casing, missing `Data` suffix on entity data struct, event not past-tense |
| **info** | Suggestion for improvement. Not a rule violation. | Missing doc comment on exported type, unused port method |

### Report Structure

```markdown
# DDD Validation Report

**Project**: {project name}
**Date**: {timestamp}
**Generator**: {generator name, e.g. go-hex}
**Contexts found**: {list}

## Summary

| Severity | Count |
|----------|-------|
| error    | N     |
| warning  | N     |
| info     | N     |

## Findings by Context

### {Context Name}

#### Domain Layer
- [error] `internal/booking/bookingdomain/cargo.go:15` — Entity ID type `CargoID` should be `CargoId` per naming convention (ref: generator.md#naming-conventions)
- [warning] ...

#### Ports Layer
...

#### Application Layer
...

#### Driven Adapters
...

#### Mock Layer
...

### Cross-Cutting

#### Dependency Direction
...

#### Cross-Context Isolation
...

#### API Contract Alignment
...
```

### Finding Format

Each finding follows this pattern:

```
[severity] `file:line` — Description (ref: pattern-file#section)
```

The `ref` field points to the pattern file and section that defines the rule being checked.

---

## Validation Phases

Execute phases in order. Each phase produces findings for the report.

### Phase 0: Discovery

**Goal**: Identify what exists in the project so subsequent phases know what to check.

**Steps**:

1. Look for `ddd-workspace/ddd-implement.manifest.json`
   - If found: extract context names, entity lists, expected file paths
   - If not found: scan `internal/` for context directories (any directory under `internal/` that contains a `{name}domain/` subdirectory is a context)

2. For each discovered context, record:
   - Context name
   - Which layers exist (domain, ports, application, mock, driven adapters)
   - Which files exist per layer

3. Check for the support infrastructure at `internal/support/`

4. Check for driving adapters at `internal/adapters/driving/`

5. Check for integration adapters at `internal/adapters/integration/`

6. Check for TypeSpec contracts at `api/`

7. Check for main wiring at `cmd/server/main.go`

**Structural findings at this phase**:
- **error**: Context directory exists but has no `{context}domain/` package
- **warning**: Expected layer directory missing entirely for a context (e.g. no `ports/` directory)
- **info**: Context found in manifest but no code exists yet (may be pending generation)

---

### Phase 1: Directory Structure Validation

**Reference**: `generators/golang/generator.md` — Directory Structure section

**Check each context against expected layout**:

```
internal/{context}/
├── {context}domain/
├── {context}application/
├── {context}mock/
└── ports/
    ├── {context}primary/
    └── {context}secondary/
```

**Rules**:

| Check | Severity | Rule |
|-------|----------|------|
| Context directory exists under `internal/` | error | Each bounded context has its own directory |
| Domain package named `{context}domain` | error | Package naming convention |
| Application package named `{context}application` | error | Package naming convention |
| Primary ports at `ports/{context}primary/` | error | Port package location |
| Secondary ports at `ports/{context}secondary/` | error | Port package location |
| Mock package named `{context}mock` | warning | Package naming convention |
| Driven adapters exist under `internal/adapters/driven/` | warning | Adapter location |
| Support packages exist under `internal/support/` | error | Required infrastructure |

---

### Phase 2: Domain Layer Validation

**Reference**: `generators/golang/patterns/domain.md`

For each context, read all `.go` files in `{context}domain/` and validate:

#### Entity ID Pattern

| Check | Severity | Rule |
|-------|----------|------|
| Entity ID type wraps `uuid.UUID` via embedding | error | Entity ID Pattern — struct must embed `uuid.UUID` |
| Constructor `New{EntityId}()` exists | error | Entity ID Pattern — constructor function |
| Parse function `{EntityId}FromString(s string)` exists | error | Entity ID Pattern — parse function with validation |
| `String()` method exists | warning | Entity ID Pattern — string representation |

#### Aggregate Root Pattern

| Check | Severity | Rule |
|-------|----------|------|
| Aggregate root embeds `basedomain.BaseEntity[{EntityId}]` | error | Aggregate Root Pattern — base entity embedding |
| Has `Data {Entity}Data` field | warning | Aggregate Root Pattern — data container convention |
| Constructor `New{Entity}(...)` returns `({Entity}, error)` | error | Aggregate Root Pattern — validated constructor |
| Constructor calls `validation.Validate()` | error | Aggregate Root Pattern — validation in constructor |
| `NewFromExisting` factory exists for repository hydration | warning | Aggregate Root Pattern — repository loading factory |
| Creation event raised in constructor via `AddEvent()` | warning | Aggregate Root Pattern — event on creation |

#### Value Object Pattern

| Check | Severity | Rule |
|-------|----------|------|
| Constructor `New{VO}(...)` returns `({VO}, error)` | error | Value Object Pattern — validated constructor |
| Constructor calls `validation.Validate()` | error | Value Object Pattern — validation in constructor |
| No ID field (value objects have no identity) | warning | Value Object Pattern — no identity |

#### Domain Event Pattern

| Check | Severity | Rule |
|-------|----------|------|
| Event type name is past tense | warning | Domain Event Pattern — past tense naming |
| Event struct has `occurredAt time.Time` field | error | Domain Event Pattern — timestamp field |
| `EventName() string` method exists | error | Domain Event Pattern — event type identifier |
| `EventName()` returns `"{context}.{event_name_snake}"` format | warning | Domain Event Pattern — event name format |
| `OccurredAt() time.Time` method exists | error | Domain Event Pattern — timestamp accessor |
| Constructor sets `occurredAt: time.Now()` | warning | Domain Event Pattern — timestamp initialization |

#### Domain Errors Pattern

| Check | Severity | Rule |
|-------|----------|------|
| `DomainValidationError` type exists with `Message` and `Cause` fields | error | Domain Errors Pattern |
| `DomainValidationError` implements `error` interface | error | Domain Errors Pattern |
| `Unwrap()` method on `DomainValidationError` for error chains | warning | Domain Errors Pattern |

---

### Phase 3: Ports Layer Validation

**Reference**: `generators/golang/patterns/ports.md`

For each context, read files in `ports/{context}primary/` and `ports/{context}secondary/`.

#### Primary Port Interface

| Check | Severity | Rule |
|-------|----------|------|
| Interface named `{Context}Service` exists | error | Primary Port Interface Pattern |
| All methods receive `context.Context` as first parameter | error | Guidelines item 5 |
| All methods return `error` as last return value | error | Guidelines item 6 |
| Methods use context-local domain types only (no cross-context imports) | error | Guidelines item 3 |
| Methods are documented with comments | info | Guidelines item 7 |

#### Secondary Port Repository Interface

| Check | Severity | Rule |
|-------|----------|------|
| Repository named `{Entity}Repository` exists for each aggregate root | error | Repository Interface Pattern |
| Standard methods present: `Store`, `FindById`, `FindAll`, `Update` | warning | Repository Interface Pattern — standard CRUD |
| All methods receive `context.Context` as first parameter | error | Guidelines item 5 |
| All methods return `error` as last return value | error | Guidelines item 6 |

#### Event Publisher Interface

| Check | Severity | Rule |
|-------|----------|------|
| `EventPublisher` interface exists in secondary ports | warning | Event Publisher Interface Pattern |
| `Publish(event basedomain.DomainEvent) error` method signature | error | Event Publisher Interface Pattern — method signature |

---

### Phase 4: Application Layer Validation

**Reference**: `generators/golang/patterns/application.md`

For each context, read files in `{context}application/`.

#### Application Service Pattern

| Check | Severity | Rule |
|-------|----------|------|
| Service struct named `{Context}ApplicationService` | error | Application Service Pattern — naming |
| Interface compliance assertion: `var _ {context}primary.{Context}Service = (*{Context}ApplicationService)(nil)` | error | Application Service Pattern — compile-time check |
| Constructor `New{Context}ApplicationService(...)` exists | error | Application Service Pattern — constructor |
| Service depends on secondary port interfaces (not concrete adapters) | error | Application Service Pattern — dependency on ports |
| Service has `logger *slog.Logger` field | info | Application Service Pattern — structured logging |
| Service has `eventPublisher` field | warning | Application Service Pattern — event publishing |

#### Permissions Pattern

| Check | Severity | Rule |
|-------|----------|------|
| Permission constants defined as `auth.Permission` type | warning | Permissions Pattern |
| `Require{Context}Permission` function exists | warning | Permissions Pattern — authorization function |
| Admin role checked first (bypass all permissions) | warning | Permissions Pattern — admin check |

#### Authorization Flow in Methods

| Check | Severity | Rule |
|-------|----------|------|
| Methods call `auth.ExtractClaims(ctx)` | warning | Guidelines item 1 — authorization first |
| Methods call the permission-check function before business logic | warning | Guidelines item 1 — authorization before logic |

#### Event Publishing

| Check | Severity | Rule |
|-------|----------|------|
| Private `publish{Entity}Events` helper method exists | info | Event Publishing Pattern |
| Events published after persistence, not before | warning | Guidelines item 4 |

---

### Phase 5: Driven Adapter Validation

**Reference**: `generators/golang/patterns/adapters.md` — Driven Adapter Patterns section

#### In-Memory Repository

| Check | Severity | Rule |
|-------|----------|------|
| Repository named `InMemory{Entity}Repository` | warning | In-Memory Repository Pattern — naming |
| Uses `sync.RWMutex` for thread safety | error | In-Memory Repository Pattern — thread safety |
| Implements the secondary port repository interface | error | In-Memory Repository Pattern — interface compliance |
| Map keyed by ID string: `map[string]{context}domain.{Entity}` | info | In-Memory Repository Pattern — storage structure |

#### Event Bus

| Check | Severity | Rule |
|-------|----------|------|
| Event bus implements `EventPublisher` interface | error | Event Bus Pattern — interface compliance |
| Uses `sync.RWMutex` for thread safety | error | Event Bus Pattern — thread safety |
| Handler errors logged but don't fail `Publish` | warning | Event Bus Pattern — error handling |

---

### Phase 6: Driving Adapter Validation

**Reference**: `generators/golang/patterns/adapters.md` — Driving Adapter Patterns section

#### HTTP Handler

| Check | Severity | Rule |
|-------|----------|------|
| Handler struct depends on primary port interface, not application service directly | error | HTTP Handler Pattern — depends on port |
| Handler methods set `Content-Type: application/json` | warning | HTTP Handler Pattern — content type |
| Request parsing uses `json.NewDecoder` | info | HTTP Handler Pattern — request parsing |
| Request validation calls `validation.Validate()` | warning | HTTP Handler Pattern — request validation |
| Error responses use consistent `ErrorResponse` struct | warning | DTO Pattern — error response |
| Success responses use consistent `SuccessResponse` struct | warning | DTO Pattern — success response |

#### Routes

| Check | Severity | Rule |
|-------|----------|------|
| `RegisterRoutes` method exists on Handler | warning | Routes Pattern — registration method |
| Protected routes wrapped with `authMiddleware.RequireAuth()` | warning | Routes Pattern — auth middleware |
| Route paths follow `/api/v1/{entities}` convention | info | Routes Pattern — path convention |

#### DTO Pattern

| Check | Severity | Rule |
|-------|----------|------|
| Request DTOs have `json` and `validate` struct tags | warning | DTO Pattern — struct tags |
| Response DTOs have `json` struct tags | warning | DTO Pattern — struct tags |
| Conversion functions `{Entity}ToResponse(...)` exist | info | DTO Pattern — domain-to-DTO conversion |

---

### Phase 7: Mock Layer Validation

**Reference**: `generators/golang/patterns/mock.md`

For each context, check `{context}mock/`.

| Check | Severity | Rule |
|-------|----------|------|
| Mock struct named `Mock{Context}Application` | warning | Mock Application Pattern — naming |
| Embeds real `*{context}application.{Context}ApplicationService` | error | Mock Application Pattern — embeds real service |
| Interface compliance assertion for primary port | error | Mock Application Pattern — `var _` assertion |
| Has seeded `*rand.Rand` field for reproducibility | warning | Mock Application Pattern — seeded randomization |
| `PopulateTest{Entities}` method exists | info | Mock Application Pattern — test data population |
| `createTestContext` creates admin claims | info | Mock Application Pattern — test context |

---

### Phase 8: Cross-Cutting Validation

These checks span the entire project, not individual contexts.

#### 8a: Dependency Direction

**Reference**: `generators/golang/generator.md` — Import Path Conventions, Validation Rules

Analyze Go import statements across all files. This is the most critical validation.

| Check | Severity | Rule |
|-------|----------|------|
| Domain packages do NOT import from application packages | error | Dependency direction: domain cannot depend on application |
| Domain packages do NOT import from adapter packages | error | Dependency direction: domain cannot depend on adapters |
| Application packages do NOT import from adapter packages | error | Dependency direction: application cannot depend on adapters |
| Domain packages import only from `support/` and standard library | error | Domain layer has minimal external dependencies |

**How to check**: For each `.go` file, extract the `import` block and compare against forbidden patterns:

```
# Forbidden import patterns (regex)
# In domain packages:
internal/.*/.*application    → error: domain imports application
internal/adapters/           → error: domain imports adapters

# In application packages:
internal/adapters/           → error: application imports adapters

# In any package:
internal/{other_context}/{other_context}domain  → error: cross-context domain import
```

#### 8b: Cross-Context Isolation

**Reference**: `generators/golang/generator.md` — Validation Rules item 2; `generators/golang/patterns/adapters.md` — Integration Adapter Patterns

| Check | Severity | Rule |
|-------|----------|------|
| No direct domain imports across context boundaries | error | Cross-context isolation |
| Cross-context calls use ACL service adapter in `internal/adapters/integration/` | warning | ACL pattern for synchronous integration |
| Cross-context events use event handler in `internal/adapters/integration/` | warning | Event handler pattern for asynchronous integration |
| Integration adapters translate between domain types (no passthrough) | info | ACL adapter must translate, not leak types |

#### 8c: API Contract Alignment

**Reference**: `bcr-to-typespec.md`, `generators/golang/patterns/adapters.md` — Driving Adapter Patterns

Only if TypeSpec contracts exist in `api/`:

| Check | Severity | Rule |
|-------|----------|------|
| TypeSpec `@route` paths match Go handler route registrations | error | Spec-first — routes must match |
| TypeSpec request/response models correspond to Go DTOs | warning | Spec-first — DTO alignment |
| Each TypeSpec endpoint has a corresponding Go handler method | warning | Spec-first — completeness |
| TypeSpec error models correspond to Go error responses | info | Spec-first — error model alignment |

#### 8d: Support Infrastructure

**Reference**: `generators/golang/generator.md` — Directory Structure

| Check | Severity | Rule |
|-------|----------|------|
| `internal/support/basedomain/` exists | error | Required support package |
| `internal/support/validation/` exists | error | Required support package |
| `internal/support/auth/` exists | error | Required support package |
| `BaseEntity` type with generic ID parameter | error | Base domain infrastructure |
| `DomainEvent` interface with `EventName()` and `OccurredAt()` | error | Base domain infrastructure |

---

## Execution Workflow

### Step 1: Announce Scope

Before validating, tell the user:
- What project you are validating
- How many contexts were discovered
- Which layers exist per context
- What the validation will cover

### Step 2: Run Phases Sequentially

Execute Phase 0 through Phase 8 in order. Use subagents for Phase 2–7 if there are many contexts, processing one context per subagent to manage context window.

### Step 3: Compile Report

Aggregate all findings into the report format. Sort findings within each section by severity (errors first, then warnings, then info).

### Step 4: Write Report

Write the report to `ddd-validation-report.md` in the project root.

### Step 5: Present Summary

Show the user:
1. Total finding counts by severity
2. The most critical errors (if any)
3. Contexts with the most findings
4. A one-line verdict: whether the project conforms, mostly conforms, or has significant violations

---

## Partial Validation

If the user wants to validate only part of the project, support these scopes:

| Scope | What gets checked |
|-------|-------------------|
| `--context {name}` | Only phases 1–7 for that context, plus cross-cutting checks involving it |
| `--layer domain` | Only Phase 2 across all contexts |
| `--layer ports` | Only Phase 3 across all contexts |
| `--layer application` | Only Phase 4 across all contexts |
| `--layer adapters` | Only Phases 5–6 across all contexts |
| `--layer mock` | Only Phase 7 across all contexts |
| `--cross-cutting` | Only Phase 8 (dependency direction, isolation, API alignment) |
| `--structure` | Only Phases 0–1 (discovery and directory layout) |

When running partial validation, still execute Phase 0 (discovery) to establish context.

---

## Using With and Without a Manifest

### With manifest (`ddd-implement.manifest.json`)

- Use `contexts[]` to know exactly which contexts and entities to expect
- Use `generatedFiles` to verify expected files exist
- Validate that entity/VO/event names in code match manifest declarations
- Report discrepancies between manifest and actual code as warnings

### Without manifest

- Discover contexts from directory structure: any directory under `internal/` containing a `{name}domain/` subdirectory
- Infer entity names from files in domain packages
- Cannot validate completeness (whether all expected entities exist), only correctness of what does exist
- Report as info that no manifest was found and completeness checks were skipped
